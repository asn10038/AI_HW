Anthony Saieva Narin

# Homework 4 Report
---

### 1) Meltdown and Spectre

#### a) What feature of processors was added that allowed for the Meltdown and Spectre attacks?
* **Out of order execution** allows for these attacks to take place. Modern processors allow instructions
to be executed out of order to make use of idle cycles while time consuming operations are taking place.

#### b) From the meltdown paper why can all of the memory be read from Linux and OS X devices but only a subset of memory can be read from Windows devices?
Windows and Linux/OSX devices manage memory differently. Linux/OSX map the entire physical memory into a predefined kernel space virtual address and rely on the CPU differentiating between privelaged and non privelaged instructions to manage access to these locations. Windows memory management doesn't map the entire physical memory into the virtual address space but instead map a large fraction of it. The meltdown attack leaks secrets bypassing privelaged mode isolation to read the entire virtual memory address space. Therefore it can read any physical memory mapped including physical memory of any other process and the kernel. However it can't read memory that isn't mapped into the virtual address space. In the case of Linux/OSX where everything is mapped into memory Meltdown can access everything, but on Windows the attack can't access memory that hasn't been mapped into the process' address space.

#### c) How does the Spectre attack differ from the Meltdown attack?
* Both Meltdown and Spectre rely on triggering speculative execution with a malicious address. Meltdown achieves this by manipulating the execution surrounding instructions that cause a trap, while Spectre achieves this by manipulating the branch predictors.
* Meltdown exploits a privelage escalation flaw in Intel and related CPU families while Spectre works with any CPU that has branch prediction which includes non intel chips like AMD and ARM processors.
* Meltdown can be mitigated by mapping minimal randomized kernel space memory into user space (KAISER + KASLR), but mitigation for Spectre is far more nuanced. One could stop speculative execution altogether but this would incur a large performance hit. The authors suggest that speculative execution can be halted on sensitive execution paths, but also say that sound solutions require changes to processor designs and updates to ISAs.
* Meltdown allows an attacker to read kernel space data and just about everything on the machine while Spectre can only access userspace information.
* Because Spectre Involves training the branch prediction units it requires normal function executions in between malicious function executions. Meltdown works everytime a program triggers a trap instruction. As such the speed of Spectre dumping data is listed at around 10KB/s while Meltdown is measured in the 100's of KB/s

### 2) Stack Canaries
###  What are canaries and how do they help prevent attacks due to buffer overflow?
 Buffer overflow attacks generally work by rewriting information on the stack, often the return address to take control of the code execution. However to do so the attacker must overwrite everything else on the stack between the variable that has the overflow and the return address. To defend against this compilers insert a canary value on the stack between the local variables that are exploited and the return address. As such if the attacker wants to overwrite the return address they also have to overwrite the canary value. If the canary value is changed the program knows a buffer overflow has taken place and will exit.

Of course if the attacker can guess the canary value this doesn't work. As such, canary values are randomly chosen at program startup. Another approach is to use terminator characters as the canary values so the attacker cannot use string functions to corrupt the stack since string functions stop copying at the first null byte.

#### What is one type of attack stack canaries don't prevent
Stack canaries can't protect against Integer Overflow attacks. Integer overflow attacks are when the value in a memory location gets bigger than the maximum value a memory location can hold. The result is the value stored in that location wraps around and goes from being very high to very low. This doesn't write to unexpected locations on the stack so stack canaries won't detect that something has been incorrectly written.

### 3) How does return oriented programming work? -- This needs to be reworked
Return oriented programming hijacks control without executing custom code. Instead it uses code that has already been loaded into the address space. If an attacker can overwrite the return address, they can force the vulnerable function to return to any place in the address space including shared libraries. Furthermore by continuing to overwrite the stack the attacker can overwrite previous return addresses which means that they can chain together function calls. The only remaining issue to solve is how to control the stack completely so arguments can be passed from call to call. To deal with this ROP takes advantage of code snippets called *gadgets*. Gadgets are pieces of code that end in a return instruction. Chaining these together allows for arbitrary code execution. Since the attacker controls the stack if they chain together gadgets that pop a source and target address from the stack with a gadget to write to an arbitrary memory location they can create an arbitrary write primitive. Another common attack is to return to some place in libc. Usually this is done to return to some function in libc that opens a shell. The last piece the attacker needs to figure out is what addresses to return to so they can execute the functions and gadgets required to carry out the attack. Address space layout randomization changes the memory layout at program run time which helps mitigate these types of attacks.
